#!/usr/bin/env node

// BUG: prompt input longer than line gets unsightly

process.env.START_AS_ROOTED = 1;

var path = require('path');
var fs = require('fs-extra');
var homeDir = process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];
var happnHome = homeDir + path.sep + '.happn';
var happnerHome = homeDir + path.sep + '.happner';

var commander = require('commander');
var happner; // = require('../');      // hard choice:
                                      //  ------------
var merge = require('merge');        // - decided to use the happner version
                                    //    from the --conf location
                                   //   - the one which that config was
                                  //      written for

// Happner / happn need to write, installed global dissallows
// So create homes

try {
  fs.lstatSync(happnHome);
} catch (e) {
  fs.mkdirpSync(happnHome);
  fs.mkdirpSync(happnHome + '/data');
  fs.mkdirpSync(happnHome + '/js');
  console.log('\nINFO: created directory ' + happnHome);
}

try {
  fs.lstatSync(happnerHome);
} catch (e) {
  fs.mkdirpSync(happnerHome);
  console.log('INFO: created directory ' + happnerHome);
}

// Primus compiles their script, need write permission
// Only necessary for global install

process.env.PRIMUS_SCRIPT = happnHome + '/js/browser_primus.js';

console.log();

var config = {
  name: 'home', // <------- your localnode
  version: '0.0.1',
  datalayer: {
    persist: true,
  },
  components: {
    'terminal': {}, // <--- first, so that other's start methods can write in command actions
    'www': {},
    'demo': {
      startMethod: 'start',
      stopMethod: 'stop'
    }
  }
};

var loaded, configPath;

// Using --conf [../some/other/file] to load a mesh node
// updates the module search paths to operate as if at
// that location.

var replaceSearchPath = function(startAt) {

  console.warn('WARN: Replacing module search path!');
  console.warn('WARN: New path starts at ' + startAt);
  console.warn('INFO: Will load happner from that location.');

  // Flush existing path to prevent false resolves
  // from the meshnode being started at --conf location

  module.paths.length = 0;

  var addPath = function(dir) {
    module.paths.push(path.normalize(dir + path.sep + 'node_modules'));
  }

  var recurse = function(dir) {
    addPath(dir);
    var next = path.dirname(dir);
    if (next.length < 2) return addPath(next);
    recurse(next);
  }

  recurse(startAt);
}

commander

.version(JSON.parse(require('fs').readFileSync(__dirname + '/../package.json')).version)
.option('')
.option('--conf [file]',         'Load mesh config from file/module (js)') // ie. module.exports = {/* the config */}
.option('',                      'use: module.exports.config = {};')
.option('',                      'or: module.exports = { /* config */ };')
.option('')
// .option('--create',              'Create new project happen project.')
// .option('')
.option('--trace',               'Set LOG_LEVEL=trace')
.option('--debug',               'Set LOG_LEVEL=debug')
.option('--warn',                'Set LOG_LEVEL=warn')
.option('')
.option('--alt-prompt [\'txt\']','Alternate prompt text')
.option('')
.parse(process.argv);

if (commander.warn)  process.env.LOG_LEVEL = 'warn';
if (commander.debug) process.env.LOG_LEVEL = 'debug';
if (commander.trace) process.env.LOG_LEVEL = 'trace';

if (commander.conf) {
  try {
    loaded = require(commander.conf);
    happner = require('../');
  } catch (e) {
    var ster = e.toString();
    try {
      configPath = process.cwd() + path.sep + commander.conf;
      loaded = require(configPath);
      replaceSearchPath(path.dirname(require.resolve(configPath)));

      try {
        happner = require('happner');
      } catch (e) {
        happner = require('../');
      }

    } catch (e) {
      console.log(ster);
      process.exit(1);
    }
  }
  config = merge.recursive(config, loaded.config || loaded);
} else {
  happner = require('../');
}

happner.start(config, function(e, mesh) {
  if (e) {
    console.log(e.toString());
    process.exit(1);
  }

  mesh.exchange.terminal.start(commander.altPrompt 
    || process.env.HAPPNER_PROMPT //  export HAPPNER_PROMPT='. '  # in .bash_profile
    || 'â–º ', function(eee, prompt) {
    // eee is array! of [e,e,e] if errors ocurred
   // prompt started anyway.
  });
});
